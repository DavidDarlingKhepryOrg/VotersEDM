//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace VotersEDM
{
    using System;
    using System.Data.Entity;
    using System.Data.Entity.Infrastructure;
    using System.Linq;
    using System.Threading.Tasks;

    public partial class VotersDBEntities : DbContext
    {
        public VotersDBEntities()
            : base("name=VotersDBEntities")
        {
        }
    
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            throw new UnintentionalCodeFirstException();
        }

        private object GetPrimaryKeyValue(DbEntityEntry entry)
        {
            var objectStateEntry = ((IObjectContextAdapter)this).ObjectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity);
            var primaryKeyValue = new Object();
            if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0) {
                primaryKeyValue = objectStateEntry.EntityKey.EntityKeyValues[0].Value;
            }
            else
            {
                primaryKeyValue = DBNull.Value;
            }
            return primaryKeyValue;
        }

        /*
         * There are a couple of significant drawbacks to this particular SaveChanges override:
         * 
         * 1. No auditing for ADDED entities. This is because, in this system,
         * the database is responsible for creating the primary key values (via IDENTITY columns)
         * and therefore the primary keys do not exist before the entity is added to the database.
         * Attempting to use the database-generated primary keys for Added entities would result
         * in two round-trips to the database on every save.
         *   
         * 2. Support for single-column primary keys only. This code makes an explicit assumption
         * that only one column per table in your database is the primary key,
         * which is not true in the real world.
         * 
         */ 
        public override int SaveChanges()
        {
            var modifiedEntities = ChangeTracker.Entries()
                .Where(p => p.State == EntityState.Modified).ToList();
            var now = DateTime.UtcNow;

            foreach (var change in modifiedEntities)
            {
                var entityName = change.Entity.GetType().Name;
                var primaryKey = GetPrimaryKeyValue(change);

                foreach (var prop in change.OriginalValues.PropertyNames)
                {
                    var originalValue = change.OriginalValues[prop].ToString();
                    var currentValue = change.CurrentValues[prop].ToString();
                    if (originalValue != currentValue)
                    {
                        ChangeLog log = new ChangeLog()
                        {
                            EntityName = entityName,
                            PrimaryKeyValue = primaryKey.ToString(),
                            PropertyName = prop,
                            OldValue = originalValue,
                            NewValue = currentValue,
                            DateChanged = now
                        };
                        ChangeLogs.Add(log);
                    }
                }
            }
            return base.SaveChanges();
        }

        /*
         * There are a couple of significant drawbacks to this particular SaveChanges override:
         * 
         * 1. No auditing for ADDED entities. This is because, in this system,
         * the database is responsible for creating the primary key values (via IDENTITY columns)
         * and therefore the primary keys do not exist before the entity is added to the database.
         * Attempting to use the database-generated primary keys for Added entities would result
         * in two round-trips to the database on every save.
         *   
         * 2. Support for single-column primary keys only. This code makes an explicit assumption
         * that only one column per table in your database is the primary key,
         * which is not true in the real world.
         * 
         */
        public override async Task<int> SaveChangesAsync()
        {
            var insertedEntities = ChangeTracker.Entries()
                .Where(p => p.State == EntityState.Added).ToList();
            var modifiedEntities = ChangeTracker.Entries()
                .Where(p => p.State == EntityState.Modified).ToList();
            var deletedEntities = ChangeTracker.Entries()
                .Where(p => p.State == EntityState.Deleted).ToList();
            var now = DateTime.UtcNow;

            foreach (var insert in insertedEntities)
            {
                var entityName = insert.Entity.GetType().Name;
                var primaryKey = GetPrimaryKeyValue(insert);

                foreach (var prop in insert.CurrentValues.PropertyNames)
                {
                    var currentValue = new Object();
                    if (insert.CurrentValues[prop] != null)
                    {
                        currentValue = insert.CurrentValues[prop].ToString();
                    }
                    else
                    {
                        currentValue = DBNull.Value.ToString();
                    }
                    ChangeLog log = new ChangeLog()
                    {
                        EntityName = entityName,
                        PrimaryKeyValue = primaryKey.ToString(),
                        PropertyName = prop,
                        OldValue = DBNull.Value.ToString(),
                        NewValue = currentValue.ToString(),
                        DateChanged = now
                    };
                    ChangeLogs.Add(log);
                }
            }

            foreach (var change in modifiedEntities)
            {
                var entityName = change.Entity.GetType().Name;
                var primaryKey = GetPrimaryKeyValue(change);

                foreach (var prop in change.OriginalValues.PropertyNames)
                {
                    var originalValue = change.OriginalValues[prop].ToString();
                    var currentValue = change.CurrentValues[prop].ToString();
                    if (originalValue != currentValue)
                    {
                        ChangeLog log = new ChangeLog()
                        {
                            EntityName = entityName,
                            PrimaryKeyValue = primaryKey.ToString(),
                            PropertyName = prop,
                            OldValue = originalValue.ToString(),
                            NewValue = currentValue.ToString(),
                            DateChanged = now
                        };
                        ChangeLogs.Add(log);
                    }
                }
            }

            foreach (var delete in deletedEntities)
            {
                var entityName = delete.Entity.GetType().Name;
                var primaryKey = GetPrimaryKeyValue(delete);

                foreach (var prop in delete.OriginalValues.PropertyNames)
                {
                    var originalValue = new Object();
                    if (delete.OriginalValues[prop] != null)
                    {
                        originalValue = delete.OriginalValues[prop].ToString();
                    }
                    else
                    {
                        originalValue = DBNull.Value.ToString();
                    }
                    ChangeLog log = new ChangeLog()
                    {
                        EntityName = entityName,
                        PrimaryKeyValue = primaryKey.ToString(),
                        PropertyName = prop,
                        OldValue = originalValue.ToString(),
                        NewValue = DBNull.Value.ToString(),
                        DateChanged = now
                    };
                    ChangeLogs.Add(log);
                }
            }

            return await base.SaveChangesAsync();
        }

        public virtual DbSet<ChangeLog> ChangeLogs { get; set; }
        public virtual DbSet<ncvoter40> ncvoter40 { get; set; }
    }
}
